# 阶段 2：数据库与核心模块 - 详细实施计划

**版本**: V1.0
**创建时间**: 2026-01-15
**预计工期**: 1-2 天
**目标**: 建立数据访问层和核心数据聚合逻辑

---

## 一、前置任务（阻塞问题修复）⚠️ 必须首先完成

### 1.1 生成初始 Migration

**问题**: 数据库表不存在，后续开发无法进行

**解决方案**:

```bash
cd backend
npm run migration:generate -- -n InitDatabase
npm run migration:run
```

**验证**:

```bash
# 检查数据库文件
ls data/weekly-report.sqlite

# 检查表结构
sqlite3 data/weekly-report.sqlite ".schema"
```

**文件位置**: `backend/src/migrations/`

---

### 1.2 修复配置校验错误

**问题**: `backend/src/config/config.schema.ts:24` 强制 email 格式，但实际配置文件使用用户名

**解决方案**:

```typescript
// backend/src/config/config.schema.ts
export const jiraConfigSchema = z.object({
  baseUrl: z.string().url(),
  email: z.string().min(1), // 改为宽松校验
  apiToken: z.string().min(1),
  jql: z.object({
    done: z.string().min(1),
    plan: z.string().min(1),
  }),
  fields: z.array(z.string()).min(1),
});
```

---

### 1.3 修复 WAL 配置

**问题**: PRAGMA 在手动 DataSource 执行，未作用于 TypeORM 的实际连接

**解决方案**:

```typescript
// backend/src/app.module.ts
TypeOrmModule.forRootAsync({
  inject: ['APP_CONFIG'],
  useFactory: async (config: AppConfig) => {
    const dataSource = createDataSource(config.database.path);

    // 初始化并执行 PRAGMA
    await dataSource.initialize();
    await dataSource.query('PRAGMA journal_mode = WAL;');
    await dataSource.query('PRAGMA busy_timeout = 5000;');
    await dataSource.query('PRAGMA synchronous = NORMAL;');
    await dataSource.query('PRAGMA cache_size = -10000;');

    return {
      type: 'sqlite',
      database: config.database.path,
      entities: dataSource.options.entities,
      synchronize: false,
      logging: false,
    };
  },
}),
```

---

### 1.4 补充 Entity 关系约束

**问题**: 现有 Entity 缺少 `@ManyToOne` 关系定义，可能产生孤儿数据

**解决方案**:

```typescript
// backend/src/entities/system-metric.entity.ts
@ManyToOne(() => ReportEntity, { onDelete: 'CASCADE' })
@JoinColumn({ name: 'report_id' })
report: ReportEntity;

// backend/src/entities/report-item.entity.ts
@ManyToOne(() => ReportEntity, { onDelete: 'CASCADE' })
@JoinColumn({ name: 'report_id' })
report: ReportEntity;

// backend/src/entities/meeting-note.entity.ts
@ManyToOne(() => ReportEntity, { onDelete: 'CASCADE' })
@JoinColumn({ name: 'report_id' })
report: ReportEntity;
```

---

### 1.5 PostgreSQL 配置锁定

**问题**: 配置 Schema 允许 MySQL，但项目仅支持 PostgreSQL

**解决方案**:

```typescript
// backend/src/config/config.schema.ts
export const externalDbConfigSchema = z.object({
  name: z.string().min(1),
  type: z.literal('postgres'), // 仅允许 postgres
  host: z.string().min(1),
  port: z.number().min(1).max(65535),
  database: z.string().min(1),
  username: z.string().min(1),
  password: z.string(),
  connectTimeoutMs: z.number().min(0),
  queryTimeoutMs: z.number().min(0),
  ssl: z.boolean(),
});
```

---

## 二、后端核心模块实施

### 2.1 JiraAdapter（Jira 数据源适配器）

**目标**: 封装 Jira REST API 调用逻辑

**文件结构**:

```
backend/src/datasources/jira/
├── jira.module.ts          # NestJS Module
├── jira.adapter.ts         # 核心适配器
├── jira.mapper.ts          # 字段映射逻辑
└── dto/
    └── jira-issue.dto.ts   # Jira Issue 类型定义
```

**核心功能**:

```typescript
// backend/src/datasources/jira/jira.adapter.ts
export class JiraAdapter {
  async fetchIssues(jql: string): Promise<JiraIssueDto[]> {
    // 1. 构建 Jira REST API 请求
    // 2. 处理分页（最多拉取 50 条）
    // 3. 重试机制（失败重试 3 次，指数退避）
    // 4. 返回标准化数据
  }

  async testConnection(): Promise<boolean> {
    // 健康检查接口
  }
}
```

**关键实现点**:

1. 使用 `axios` 发送请求（Basic Auth）
2. 处理 Jira 分页（`startAt` + `maxResults`）
3. 错误处理：401/403/429/500
4. 字段映射：`customfield_*` → 业务字段

**测试验证**:

```typescript
// 单元测试
describe('JiraAdapter', () => {
  it('should fetch issues successfully', async () => {
    const issues = await adapter.fetchIssues('project = TEST');
    expect(issues).toBeDefined();
  });
});
```

---

### 2.2 SqlAdapter（PostgreSQL 数据源适配器）

**目标**: 封装外部数据库查询逻辑

**文件结构**:

```
backend/src/datasources/sql/
├── sql.module.ts
├── sql.adapter.ts
└── dto/
    └── metric-result.dto.ts
```

**核心功能**:

```typescript
// backend/src/datasources/sql/sql.adapter.ts
export class SqlAdapter {
  private pools: Map<string, Pool>; // pg 连接池

  async queryMetrics(weekNumber: number): Promise<MetricResultDto[]> {
    // 1. 执行配置的 SQL 查询
    // 2. 参数化查询（防止注入）
    // 3. 超时控制（15 秒）
    // 4. 返回标准化数据
  }

  async testConnection(dbName: string): Promise<boolean> {
    // 健康检查
  }
}
```

**关键实现点**:

1. 使用 `pg` 库创建连接池
2. 配置超时：`connectTimeoutMillis: 5000`, `statement_timeout: 15000`
3. 参数化查询：`query(sql, [weekNumber])`
4. 仅允许 SELECT 语句（校验 SQL）

**安全措施**:

```typescript
// 校验 SQL 语句
if (!sql.trim().toUpperCase().startsWith('SELECT')) {
  throw new Error('Only SELECT queries are allowed');
}
```

---

### 2.3 GenerateService（周报生成核心服务）

**目标**: 编排数据拉取、转换、事务写入

**文件结构**:

```
backend/src/modules/generate/
├── generate.module.ts
├── generate.service.ts
├── generate.controller.ts
└── dto/
    ├── generate-response.dto.ts
    └── report-snapshot.dto.ts
```

**核心流程**:

```typescript
// backend/src/modules/generate/generate.service.ts
export class GenerateService {
  async generateSnapshot(): Promise<ReportEntity> {
    // 1. 计算周期（date-fns）
    const weekStart = startOfWeek(new Date(), { weekStartsOn: 1 });
    const weekNumber = getISOWeek(new Date());

    // 2. 并发拉取数据（Promise.allSettled）
    const [jiraDone, jiraPlan, sqlMetrics] = await Promise.allSettled([
      this.jiraAdapter.fetchIssues(this.config.jira.jql.done),
      this.jiraAdapter.fetchIssues(this.config.jira.jql.plan),
      this.sqlAdapter.queryMetrics(weekNumber),
    ]);

    // 3. 数据转换
    const reportId = this.idService.nextId();
    const report = this.buildReport(reportId, weekStart, weekNumber);
    const metrics = this.buildMetrics(reportId, sqlMetrics);
    const items = this.buildItems(reportId, jiraDone, jiraPlan);
    const note = this.buildNote(reportId);

    // 4. 单事务写入
    return await this.transactionalSave(report, metrics, items, note);
  }
}
```

**关键实现点**:

1. **幂等性**: 检查是否已存在同周周报
2. **错误处理**: `Promise.allSettled` 部分失败仍可继续
3. **事务保证**: 使用 TypeORM QueryRunner
4. **数据映射**: Jira Issue → ReportItem

**错误处理示例**:

```typescript
if (jiraDone.status === 'rejected') {
  this.logger.warn('Jira Done 拉取失败，使用空数据', jiraDone.reason);
}
```

---

## 三、前端核心模块实施

### 3.1 TypeScript 类型定义

**文件**: `frontend/src/types/index.ts`

**核心类型**:

```typescript
export interface Report {
  id: string;
  weekRange: string; // 改为 camelCase
  weekNumber: number;
  createdAt: string;
  isDeleted: boolean;
}

export interface SystemMetric {
  id: string;
  reportId: string; // 改为 camelCase
  metricKey: 'TOTAL_COUNT' | 'PROCESS_COUNT' | 'MANUAL_COUNT' | 'VERIFY_ETL' | 'REVIEW_ETL';
  metricValue: string;
  statusCode: 'loading' | 'success' | 'normal';
}

export interface ReportItem {
  id: string;
  reportId: string;
  tabType: 'DONE' | 'SELF' | 'PLAN';
  sourceType: 'JIRA' | 'SQL' | 'MANUAL';
  parentId: string | null;
  contentJson: ReportItemContent;
  sortOrder: number;
  children?: ReportItem[]; // 前端树结构
}

export interface ReportItemContent {
  jiraKey?: string;
  taskName: string;
  status?: string;
  owner?: string;
  eta?: string;
  // ... 其他字段
}
```

**关键修改**:

- 所有字段改为 `camelCase`（对齐后端 API 输出）
- ID 强制 `string` 类型（BIGINT 序列化）

---

### 3.2 API 服务层

**文件**: `frontend/src/services/api.ts`

**核心接口**:

```typescript
import axios from '@/lib/axios';

export const api = {
  // 生成周报
  generateReport: () =>
    axios.post<{ reportId: string }>('/api/reports/generate'),

  // 获取周报列表
  getReports: () =>
    axios.get<{ items: Report[] }>('/api/reports'),

  // 获取周报详情
  getReportDetail: (id: string) =>
    axios.get<ReportDetail>(`/api/reports/${id}`),
};
```

---

### 3.3 React Query Hooks

**文件**: `frontend/src/services/reportHooks.ts`

**核心 Hooks**:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// 查询周报列表
export const useReports = () => {
  return useQuery({
    queryKey: ['reports'],
    queryFn: () => api.getReports(),
  });
};

// 生成周报
export const useGenerateReport = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: () => api.generateReport(),
    onSuccess: () => {
      // 刷新列表
      queryClient.invalidateQueries({ queryKey: ['reports'] });
    },
  });
};
```

---

## 四、实施顺序与验证

### 步骤 1：修复阻塞问题（30 分钟）

**任务清单**:

- [ ] 生成 Migration
- [ ] 修复 Jira email 校验
- [ ] 修复 WAL 配置
- [ ] 补充 Entity 关系约束
- [ ] 锁定 PostgreSQL 类型

**验证**:

```bash
cd backend
npm run start:dev

# 检查日志：
# ✅ SQLite 已初始化（WAL 模式）
# ✅ 配置加载成功
```

---

### 步骤 2：后端适配器（2-3 小时）

**任务清单**:

- [ ] 实现 JiraAdapter
- [ ] 实现 SqlAdapter
- [ ] 编写单元测试

**验证**:

```bash
# 测试 Jira 连接
curl http://localhost:3000/api/health/jira

# 测试 SQL 连接
curl http://localhost:3000/api/health/sql
```

---

### 步骤 3：GenerateService（1-2 小时）

**任务清单**:

- [ ] 实现 generateSnapshot 核心逻辑
- [ ] 实现数据转换方法
- [ ] 实现事务写入
- [ ] 创建 GenerateController

**验证**:

```bash
# 触发周报生成
curl -X POST http://localhost:3000/api/reports/generate

# 检查数据库
sqlite3 data/weekly-report.sqlite "SELECT * FROM reports;"
```

---

### 步骤 4：前端基础（1 小时）

**任务清单**:

- [ ] 定义 TypeScript 类型
- [ ] 实现 API 服务层
- [ ] 实现 React Query Hooks
- [ ] 创建最小 UI（生成按钮）

**验证**:

```tsx
// frontend/src/App.tsx
import { useGenerateReport } from '@/services/reportHooks';

function App() {
  const { mutate, isLoading } = useGenerateReport();

  return (
    <button onClick={() => mutate()} disabled={isLoading}>
      {isLoading ? '生成中...' : '生成周报'}
    </button>
  );
}
```

---

## 五、验收标准

### 5.1 后端验收

- [ ] 数据库表创建成功（4 张表 + 索引）
- [ ] WAL 模式已启用（检查 `PRAGMA journal_mode`）
- [ ] Jira API 可正常调用（返回 Issue 列表）
- [ ] PostgreSQL 查询可执行（返回指标数据）
- [ ] POST /api/reports/generate 返回 reportId
- [ ] 生成的数据正确写入数据库

### 5.2 前端验收

- [ ] TypeScript 类型无编译错误
- [ ] API 请求可成功发送
- [ ] React Query 缓存生效
- [ ] 生成按钮点击后有加载状态
- [ ] 生成成功后展示 reportId

### 5.3 端到端验收

- [ ] 前端点击生成按钮 → 后端拉取数据 → 数据库写入成功
- [ ] 生成过程耗时 < 10 秒
- [ ] 生成失败时前端显示错误提示

---

## 六、风险与缓解

| 风险              | 缓解措施                  |
|-----------------|-----------------------|
| Jira API 限流     | 重试机制 + 降级（仅生成空周报）     |
| PostgreSQL 连接超时 | 超时控制 + 降级（指标显示"加载失败"） |
| 并发写入冲突          | WAL 模式 + busy_timeout |
| 数据转换错误          | 充分的单元测试 + 日志记录        |

---

## 七、下一步（阶段 3）

完成阶段 2 后，将进入阶段 3：

- [ ] 实现 ReportsController（列表、详情、删除）
- [ ] 实现 ItemsController（单行编辑）
- [ ] 实现 NotesController（会议待办）
- [ ] 前端 MetricDashboard 组件
- [ ] 前端 WeeklyDoneTable 组件

---

**文档结束**

请按照本计划逐步实施，确保每个步骤都经过验证后再进入下一步。
